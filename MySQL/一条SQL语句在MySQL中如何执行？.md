# 一条SQL语句在MySQL中如何执行？

## MySQL的基本架构示意图

![image-20220204162107915](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220204162107915.png)

简单来说 MySQL  主要分为 Server 层和存储引擎层：

- **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
- **存储引擎**： 主要负责数据的存储和读取，采用**可以替换的插件式架构**，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redo log 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**

### Server 层基本组件介绍

#### 连接器

连接命令一般是这么写的：`mysql -h$ip -P$port -u$user -p`

- 如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
- 如果用户名密码认证通过，连接器会到**权限表**里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，**都将依赖于此时读到的权限**。

这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

#### 查询缓存(MySQL 8.0 版本后移除)

连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。

**但是大多数情况不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**

查询缓存的失效非常频繁，**只要有对一个表的更新，这个表上所有的查询缓存都会被清空**。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。**除非你的业务就是有一张静态表，很长时间才会更新一次**。比如，一个**系统配置表**，那这张表上的查询才适合使用查询缓存。

好在MySQL也提供了这种“按需使用”的方式。你可以将参数**query_cache_type设置成DEMAND**，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：

```
mysql> select SQL_CACHE * from T where ID=10；
```

需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。

#### 分析器

MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：

**第一步，词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

**第二步，语法分析**，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。

- 若一个表的写错了，没有相应字段，语法错误，就在这里检查出来而报错

- ```sql
  mysql> select * from em;
  ERROR 1146 (42S02): Table 'bjpowernode.em' doesn't exist
  ```

- ```sql
  mysql> select a from emp;
  ERROR 1054 (42S22): Unknown column 'a' in 'field list'
  ```

- ```sql
  mysql> selec ename from emp;
  ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'selec ename from emp' at line 1
  ```

完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

#### 优化器

经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

优化器是在表里面有多个索引的时候，**决定使用哪个索引**；或者在一个语句有多表关联（join）的时候，**决定各个表的连接顺序**。比如你执行下面这样的语句，这个语句是执行两个表的join：

```
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

- 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
- 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。

#### 执行器

当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。



## 查询语句执行过程

```sql
select * from tb_student  A where A.age=18 and A.name=' 张三 ';
```

- 1、**连接器：**查询语句执行前要先连接数据库，这是连接器的工作。
- 2、**查询缓存：**在 MySQL8.0 版本以前，会先**查询缓存**，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
- 3、**分析器：**进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。 
  - 在分析器阶段就会顺便看看是否有查询的表，查询的字段，比如实际有的表是`tbl_student`,那么就会报错，告诉你表`tb_student not exists`
- 4、**优化器：**优化器进行确定执行方案，上面这条sql可以有两张方案
  - 先查询age = 18的记录，再判断name
  - 先查询name = '张三'的记录，再判断age
  - 优化器会根据自己的算法选择执行效率最好的一个方案
- 5、**执行器：**进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。
  - 若这时候登录的用户，对表`tb_student`有`select`权限的话，大致的执行流程如下（假设没有索引）：
  - 1、调用InnoDB的接口取这个表的第一行，判断age和name是否符合，如果符合，将这行加入结果集
  - 2、调用引擎接口取下一行，重复相同的判断逻辑，直到取到表的最后一行
  - 3、将结果集返回客户端

### TODO

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。

可以在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此**引擎扫描行数跟rows_examined并不是完全相同的。**



## 更新语句执行过程

```sql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```

其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 **binlog（归档日志）** ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 **redo log（重做日志）**，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

- 1、**连接器：**执行语句前要先连接数据库，这是连接器的工作。
- 2、**查询缓存**：在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。
- 3、**分析器：**分析器会通过词法和语法解析知道这是一条更新语句。且检验表名，字段是否存在
- 4、**优化器：**优化器决定要使用ID这个索引
- 5、**执行器：**执行器负责具体执行，找到这一行，然后更新
  - 执行器和InnoDB引擎在执行这个简单的update语句时的内部流程：
  - 1.执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
  - 2.执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
  - 3.引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时**redo log处于prepare状态**。然后告知执行器执行完成了，随时可以提交事务。
  - 4.执行器**生成这个操作的binlog，并把binlog写入磁盘**。
  - 5.执行器调用引擎的提交事务接口，引擎把刚刚写入的**redo log改成提交（commit）状态**，更新完成。

<img src="https://raw.githubusercontent.com/xuhaoyao/images/master/img/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="2e5bff4910ec189fe1ee6e2ecc7b4bbe" style="zoom: 33%;" />



