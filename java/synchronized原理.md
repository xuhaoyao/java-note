# synchronized原理

java高并发核心编程：卷2，有对锁升级详细的代码验证，遗忘的话可以再去翻一翻

## 锁升级

![image-20220317155000087](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220317155000087.png)

JDK5的时候，Doug lea大师编写的JUC包下API层面的锁的性能都比synchronized锁的性能快很多，因此，在JDK6后，Java对synchronized锁进行了一个升级，主要包含偏向锁，轻量级锁和重量级锁。

（1）偏向锁

为什么要引入偏向锁？

HotSpot的作者经过研究发现，大多数时候，锁都是不存在竞争的，常常是一个线程多次获取同一个锁，因此如果每次都要竞争锁会增大很多没有必要的代价，为了降低锁获取的代价，引入了偏向锁。

**偏向锁的获取与升级**

当锁对象第一次被线程获取的时候，比如线程1访问代码块并获取锁对象时，会使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中,因为偏向锁不会主动释放锁，因此以后线程再次获取锁的时候，需要比较当前线程的Thread ID和Java对象头的Thread ID是否一致。

- 如果一致，那么此时线程就获取到了锁，就不需要使用CAS来加锁和解锁
- 如果不一致，比如现在是线程2来竞争锁，而偏向锁不会主动释放，因此这时候Mark Word中存储的是线程1的Thread ID,那么需要通过线程1的Thread ID查看线程1是否存活
  - 如果没有存活，那么锁对象被重置为无锁状态，线程2就可以竞争将其设置为**轻量级锁**
  - 如果存活，那么会去查找线程1的栈帧信息
    - **如果线程1现在还持有这个锁对象，那么暂停当前线程1，撤销偏向锁（需要等待全局安全点，这个时间点没有正在执行的字节码），升级为轻量级锁**
    - 如果线程1不再使用这个锁，那么将锁置为无锁状态，线程2可以竞争将其设置为**轻量级锁**
- **一个原则：**偏向锁在一个对象上，只能被一个线程拿到，当另外的线程来拿这个对象的锁时，偏向锁的偏向模式就失效了，此后就在这个对象上就没有偏向锁了，即对象的偏向锁的那个标志位为0

（2）轻量级锁

轻量级锁设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。主要还是一种乐观锁的思想。**因为阻塞线程需要CPU从用户态转到内核态，线程上下文切换的代价很大，如果刚刚阻塞不久这个锁就被释放了，那么这时候还不如不阻塞，采用自旋的方式等待锁的释放。**

**轻量级锁的获取和升级**

线程1获取轻量级锁的时候首先在**当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间**，用于存储锁对象目前的Mark Word的拷贝（Displaced Mark Word），使用CAS把对象头中的Mark Word更新为指向Lock Record的指针。

- 如果这个更新操作成功了，此对象目前就处于轻量级锁定的状态。
- 如果这时候线程2也准备获取锁，它也会创建一个Lock Record在自己的栈帧中，但是在线程2CAS的时候，线程1已经把对象头给换了，这时候线程2CAS失败，那么线程2就会尝试使用自旋来等待线程1释放锁。
  - **默认自旋10次，如果自旋10次还还没释放锁的话，那么此时升级为重量级锁。**
    - 这里默认是10次，其实这里还涉及到一个自适应自旋的优化。如果在同一个锁对象上，自旋获取锁的时候成功过，那么虚拟机就会认为此次自旋也很有可能再次获取锁，那么就允许自旋的次数更长一些，比如**持续自旋100次**，然而，若对于某个锁，自旋很少成功获得过锁，那么在以后要获取这个锁的时候就可能直接省略掉自旋的过程。
  - **如果出现两条以上的线程来竞争锁，那么这个时候轻量级锁就会升级为重量级锁。**
  - 重量级锁把除了拥有锁的线程以外的都阻塞，防止了CPU空转。

> 注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。
>
> - 这句话是在什么场景下说的？我觉得是：抢锁的时候
>   - 通过jol的测试验证，当锁释放的时候，偏向锁不改变对象头（占着锁不放），轻量级锁和重量级锁，都变成无锁状态
>   - 即，当一个重量级锁解锁之后，对象现在是无锁状态，下一次线程来拿锁，锁可以变成轻量级锁

**轻量级锁的解锁过程**

解锁过程同样使用CAS操作来进行，如果对象的Mark Word仍然指向线程的Lock Record，那么就用CAS把对象当前的Mark Word和Lock Record中复制的Displaced Mark Word替换回来。

- 如果能够替换成功，那么整个同步过程就顺利完成了
- 如果替换失败，说明原先指向栈帧中Lock Record的指针变成了重量级锁，就要在释放锁的同时，唤醒被挂起的线程。

> 如果没有竞争，轻量级锁通过CAS操作成功避免了使用互斥量的开销；如果确实存在锁竞争，除了互斥量的本身开销，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而比传统的重量级锁更慢。
>
> 当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁的状态了，而当一个对象当前正在处于偏向锁状态，又需要**计算一致性哈希码请求**（指的是Object::hashCode()或者System::identityHashCode(Object)的调用，如果重写了对象的HashCode方法，不算这里所说的请求）时，它的偏向状态立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类有字段可以记录非加锁状态下的Mark Word，其中自然可以存储哈希码。
>
> - 对于重写过hashCode的对象，为了保证一致性哈希，通常可以在用到的时候才计算，且只计算一次，在对象中保存这个hash值，String就是这么做的



## 锁消除

基于逃逸分析，如果发现一段代码里面的对象不会逃逸出去被其他线程访问到，那么可以将它们当作栈上数据对待，认为它们是线程私有的，同步加锁就无须再进行。

```java
public String concatString(String a,String b){
    StringBuffer sb = new StringBuffer();
    sb.append(a);
    sb.append(b);
    return sb.toString();
}
```

每个StringBuffer.append都有一个同步块，虚拟机观察sb变量发现它不会逃逸出方法外面被其他线程访问，那么在经过服务器编译器的即时编译后，这段代码的同步措施就会被消除掉。



## 锁粗化

如果一系列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁都是出现在循环体中，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

比如上面的代码，可以把加锁范围扩展到第一个append操作之前，直到最后一个append操作之后，这样只需要一次加锁



## 重量级锁核心原理

JVM中每个对象都会有一个监视器，监视器和对象一起创建、销 毁。监视器相当于一个用来监视这些线程进入的特殊房间，其义务是 保证(同一时间)只有一个线程可以访问被保护的临界区代码块。

 本质上，监视器是一种同步工具，也可以说是一种同步机制，主要特点是:

(1)同步。监视器所保护的临界区代码是互斥地执行的。一个监 视器是一个运行许可，任一线程进入临界区代码都需要获得这个许 可，离开时把许可归还。

(2)协作。监视器提供Signal机制，允许正持有许可的线程暂时 放弃许可进入阻塞等待状态，等待其他线程发送Signal去唤醒;其他 拥有许可的线程可以发送Signal，唤醒正在阻塞等待的线程，让它可 以重新获得许可并启动执行。

在Hotspot虚拟机中，监视器是由C++类ObjectMonitor实现的， ObjectMonitor类定义在ObjectMonitor.hpp文件中，其构造器代码大 致如下:

![image](https://user-images.githubusercontent.com/56396192/168463934-58a349cb-2b44-4de1-be96-d39580a4774f.png)

![image](https://user-images.githubusercontent.com/56396192/168463945-81b7eea8-9ef6-437c-9558-5df67771750f.png)

ObjectMonitor的Owner(_owner)、WaitSet(_WaitSet)、 Cxq(_cxq)、EntryList(_EntryList)这几个属性比较关键。 ObjectMonitor的WaitSet、Cxq、EntryList这三个队列存放抢夺重量 级锁的线程，而ObjectMonitor的Owner所指向的线程即为获得锁的线 程。

Cxq、EntryList、WaitSet这三个队列的说明如下:

(1)Cxq:竞争队列(Contention Queue)，所有请求锁的线程 首先被放在这个竞争队列中。

(2)EntryList:Cxq中那些有资格成为候选资源的线程被移动到 EntryList中。

(3)WaitSet:某个拥有ObjectMonitor的线程在调用 Object.wait()方法之后将被阻塞，然后该线程将被放置在WaitSet链 表中。

![image](https://user-images.githubusercontent.com/56396192/168463959-643397fe-462c-43b7-a1e8-052ac8d26cc3.png)

### cxq

Cxq并不是一个真正的队列，只是一个虚拟队列，原因在于Cxq是 由Node及其next指针逻辑构成的，并不存在一个队列的数据结构。每 次新加入Node会在Cxq的队头进行，通过CAS改变第一个节点的指针为 新增节点，同时设置新增节点的next指向后续节点;从Cxq取得元素 时，会从队尾获取。显然，Cxq结构是一个无锁结构。

因为只有Owner线程才能从队尾取元素，即线程出列操作无争用， 当然也就避免了CAS的ABA问题.

在线程进入Cxq前，抢锁线程会先尝试通过CAS自旋获取锁，如果 获取不到，就进入Cxq队列，这明显对于已经进入Cxq队列的线程是不 公平的。所以，synchronized同步块所使用的重量级锁是不公平锁。



### EntryList

EntryList与Cxq在逻辑上都属于等待队列。Cxq会被线程并发访 问，为了降低对Cxq队尾的争用，而建立EntryList。在Owner线程释放 锁时，JVM会从Cxq中迁移线程到EntryList，并会指定EntryList中的 某个线程(一般为Head)为OnDeck Thread(Ready Thread)。 EntryList中的线程作为候选竞争线程而存在。



### OnDeck Thread与Owner Thread

JVM不直接把锁传递给Owner Thread，而是把锁竞争的权利交给 OnDeck Thread，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平 性，但是能极大地提升系统的吞吐量，在JVM中，也把这种选择行为称 为“竞争切换”。

OnDeck Thread获取到锁资源后会变为Owner Thread。无法获得锁 的OnDeck Thread则会依然留在EntryList中，考虑到公平性，OnDeck Thread在EntryList中的位置不发生变化(依然在队头)。

在OnDeck Thread成为Owner的过程中，还有一个不公平的事情， 就是后来的新抢锁线程可能直接通过CAS自旋成为Owner而抢到锁。



### WaitSet

如果Owner线程被Object.wait()方法阻塞，就转移到WaitSet队列 中，直到某个时刻通过Object.notify()或者Object.notifyAll()唤 醒，该线程就会重新进入EntryList中。





在这里改动，会怎样
