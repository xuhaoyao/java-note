# synchronized原理

## 锁升级

![image-20220317155000087](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220317155000087.png)

JDK5的时候，Doug lea大师编写的JUC包下API层面的锁的性能都比synchronized锁的性能快很多，因此，在JDK6后，Java对synchronized锁进行了一个升级，主要包含偏向锁，轻量级锁和重量级锁。

（1）偏向锁

为什么要引入偏向锁？

HotSpot的作者经过研究发现，大多数时候，锁都是不存在竞争的，常常是一个线程多次获取同一个锁，因此如果每次都要竞争锁会增大很多没有必要的代价，为了降低锁获取的代价，引入了偏向锁。

**偏向锁的获取与升级**

当锁对象第一次被线程获取的时候，比如线程1访问代码块并获取锁对象时，会使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中,因为偏向锁不会主动释放锁，因此以后线程再次获取锁的时候，需要比较当前线程的Thread ID和Java对象头的Thread ID是否一致。

- 如果一致，那么此时线程就获取到了锁，就不需要使用CAS来加锁和解锁
- 如果不一致，比如现在是线程2来竞争锁，而偏向锁不会主动释放，因此这时候Mark Word中存储的是线程1的Thread ID,那么需要通过线程1的Thread ID查看线程1是否存活
  - 如果没有存活，那么锁对象被重置为无锁状态，线程2就可以竞争将其设置为偏向锁
  - 如果存活，那么会去查找线程1的栈帧信息
    - **如果线程1现在还持有这个锁对象，那么暂停当前线程1，撤销偏向锁（需要等待全局安全点，这个时间点没有正在执行的字节码），升级为轻量级锁**
    - 如果线程1不再使用这个锁，那么将锁置为无锁状态，重新偏向新的线程。

（2）轻量级锁

轻量级锁设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。主要还是一种乐观锁的思想。**因为阻塞线程需要CPU从用户态转到内核态，线程上下文切换的代价很大，如果刚刚阻塞不久这个锁就被释放了，那么这时候还不如不阻塞，采用自旋的方式等待锁的释放。**

**轻量级锁的获取和升级**

线程1获取轻量级锁的时候首先在**当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间**，用于存储锁对象目前的Mark Word的拷贝（Displaced Mark Word），使用CAS把对象头中的Mark Word更新为指向Lock Record的指针。

- 如果这个更新操作成功了，此对象目前就处于轻量级锁定的状态。
- 如果这时候线程2也准备获取锁，它也会创建一个Lock Record在自己的栈帧中，但是在线程2CAS的时候，线程1已经把对象头给换了，这时候线程2CAS失败，那么线程2就会尝试使用自旋来等待线程1释放锁。
  - **默认自旋10次，如果自旋10次还还没释放锁的话，那么此时升级为重量级锁。**
    - 这里默认是10次，其实这里还涉及到一个自适应自旋的优化。如果在同一个锁对象上，自旋获取锁的时候成功过，那么虚拟机就会认为此次自旋也很有可能再次获取锁，那么就允许自旋的次数更长一些，比如**持续自旋100次**，然而，若对于某个锁，自旋很少成功获得过锁，那么在以后要获取这个锁的时候就可能直接省略掉自旋的过程。
  - **如果出现两条以上的线程来竞争锁，那么这个时候轻量级锁就会升级为重量级锁。**
  - 重量级锁把除了拥有锁的线程以外的都阻塞，防止了CPU空转。

> 为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。

**轻量级锁的解锁过程**

解锁过程同样使用CAS操作来进行，如果对象的Mark Word仍然指向线程的Lock Record，那么就用CAS把对象当前的Mark Word和Lock Record中复制的Displaced Mark Word替换回来。

- 如果能够替换成功，那么整个同步过程就顺利完成了
- 如果替换失败，说明原先指向栈帧中Lock Record的指针变成了重量级锁，就要在释放锁的同时，唤醒被挂起的线程。

> 如果没有竞争，轻量级锁通过CAS操作成功避免了使用互斥量的开销；如果确实存在锁竞争，除了互斥量的本身开销，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而比传统的重量级锁更慢。
>
> 当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁的状态了，而当一个对象当前正在处于偏向锁状态，又需要**计算一致性哈希码请求**（指的是Object::hashCode()或者System::identityHashCode(Object)的调用，如果重写了对象的HashCode方法，不算这里所说的请求）时，它的偏向状态立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类有字段可以记录非加锁状态下的Mark Word，其中自然可以存储哈希码。
>
> - 对于重写过hashCode的对象，为了保证一致性哈希，通常可以在用到的时候才计算，且只计算一次，在对象中保存这个hash值，String就是这么做的



## 锁消除

基于逃逸分析，如果发现一段代码里面的对象不会逃逸出去被其他线程访问到，那么可以将它们当作栈上数据对待，认为它们是线程私有的，同步加锁就无须再进行。

```java
public String concatString(String a,String b){
    StringBuffer sb = new StringBuffer();
    sb.append(a);
    sb.append(b);
    return sb.toString();
}
```

每个StringBuffer.append都有一个同步块，虚拟机观察sb变量发现它不会逃逸出方法外面被其他线程访问，那么在经过服务器编译器的即时编译后，这段代码的同步措施就会被消除掉。



## 锁粗化

如果一系列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁都是出现在循环体中，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

比如上面的代码，可以把加锁范围扩展到第一个append操作之前，直到最后一个append操作之后，这样只需要一次加锁