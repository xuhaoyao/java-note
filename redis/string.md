# string

Redis没有直接使用传统C语言的字符串，而是自己构建了一个名为SDS的简单动态字符串。

```c
struct sdshdr{
    
    //记录buf数组中已使用字节的数量
    //等于SDS所保存字符串的长度
    int len;
    
    //记录buf数组中未使用字节的数量
    int free;
    
    //字节数组,用于保存字符串
    char buf[];
}
```

**SDS遵循了C语言以空字符'\0'结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间。这个空字符由SDS函数自动完成，对用户是透明的**

**遵循空字符'\0'结尾的好处就是SDS可以直接重用一部分C语言字符串的库函数**

SDS的优点：

- 通过len字段**常数复杂度获取字符串长度**，C语言通过strlen取长度，时间为O（n），而Redis只需要查看len字段，时间为O（1）
- **杜绝缓冲区溢出**：当SDS需要修改时，先检查SDS的空间是否满足修改所需的大小，如果不满足的话，API会自动将SDS的空间扩展至修改所需的大小，然后才执行实际的修改操作。
- **空间预分配，减少修改字符串长度时所需的内存重分配次数：**
  - 首先，SDS的字节数组的实际长度为：len+free+1（+1是因为有一个空字符结尾）
  - 如果对SDS进行修改后，SDS的长度（len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同
    - 举个例子，修改后，SDS的len变成了13字节，那么程序也会分配13字节的未使用空间，这时候SDS的字节数组实际长度就是13+13+1=27字节
  - 如果对SDS进行修改后，长度大于等于1MB，那么程序会分配1MB未使用空间
    - 举个例子，修改后，SDS的len长度是30MB，那么SDS的字节数组实际上的长度为30MB+1MB+1字节
  - 通过空间预分配，Redis可以减少连续执行字符串增长操作（append）所需的内存重分配次数。
    - 举个例子，一开始SDS的len是5,free是0，字节数组里面存了“Redis”
    - 这时候,append一个Redis，这时候因为字节数组不够用了，需要内存重分配，那么SDS现在就是,len是10，free是10，char数组里面存了"RedisRedis"
    - 那么下一次再append一个Redis，就不需要内存重分配了，因为现在长度还够用

- **惰性空间释放：**
  - 当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收多出来的字节，而是使用free字段将这些字节数量记录起来，等待将来使用。
  - SDS也提供了相应的API，可以让我们有需要的时候真正释放SDS的未使用空间。

- **二进制安全**
  - SDS的buf属性叫做字节数组的原因，就是因为Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据。
    - 因为Redis使用的是SDS的len属性来判断字符串是否结束，所以对于字符串中间出现的一些'\0'，Redis也能够读取，而传统C语言遇到'\0'就结束了
    - 通过使用二进制安全的SDS而不是C字符串，Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。
- **兼容部分C字符串函数**
  - 因为SDS遵循了C字符串以空字符结尾的惯例，就可以让那些保存了文本数据的SDS可以重用一部分C语言的<string.h>库函数
    - 就比如strcat，strcmp这些