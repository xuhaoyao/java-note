# 分布式事务--订单问题

在以往的单体应用中，我们多个业务操作使用同一条数据库连接来操作不同的数据库，一旦有异常，**可以很容易的整体回滚**。

![image-20220314091857421](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220314091857421.png)

比如买东西的业务，扣库存，下订单，账户扣款，由于事务的特性，这三个操作是一个整体，要么同时成功要么同时失败。

**随着互联网的发展，分布式系统把以往的一个单体应用拆分成了可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作。**



## 2PC

2PC即两阶段提交协议，将整个事务流程分为两个阶段，准备阶段和提交阶段。

准备阶段：事务管理器给每个参与者发送Prepare消息，每个数据库在本地执行事务，写Undo/Redo日志，但还没有提交。

提交阶段：如果事务管理器收到了参与者执行失败或超时的消息，直接给**每个参与者发送回滚消息**，否则发送提交消息。

**在最后阶段才释放锁资源。**

![image-20220314113439519](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220314113439519.png)

![image-20220314113446752](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220314113446752.png)



## 项目的订单问题

**柔性事务-可靠消息-最终一致性方案**

> 刚性事务：遵循ACID原则，强一致性。
>
> 柔性事务：遵循BASE理论，最终一致性。
>
> 柔性事务允许一定时间内不同节点的数据不一致，但要求一定时间后最终一致。

项目中的库存数量和已锁定库存数量，用户下订单的时候锁定库存，在这之后用户可能将这个订单取消了，但这时候库存数量还是已经锁定的状态，这一阶段就是**软状态**，而我们发往MQ的消息是有过期的时间的，保证了在一段时间的同步后，这个库存能被解锁，实现最终一致性。

> 核心就是：
>
> - 每个订单有自己目前的状态
> - 每锁定一个库存，都有它相应的库存工作单(记录了这个库存是锁定的还是已经解锁了的)
>



首先，用户点击立即购买，可以来到一个订单页，来到订单页的时候就已经锁定好库存了。

![image-20220315203455749](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220315203455749.png)

![image-20220315203814298](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220315203814298.png)



### 超卖问题

项目中的一个bug，没有解决。

![image-20220314135429253](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220314135429253.png)

能想到的解决方案如下:

- 悲观锁

  - select ... for update，读库存的时候，直接加写锁，这样用户a读数据库时，用户b就需要等待

  - 当并发量很高时，处理效率大大降低，但是我们这是平常普通的订单，应该也可用。

- 乐观锁

  - 为数据库表增加一个version字段实现
  - 读取数据时将version字段一同读出，数据每更新一次对此version值加1
  - `update tableName set version = #{version} + 1 where version = #{version}`

  - 当我们更新时，判断数据库中的version与自己读到的version是否一致，若相等则进行更新，否则认为是过期数据。
  - **乐观锁核心思想：当值和期待值相同时，就认为是正确数据，可以进行更新**

- Redis分布式锁