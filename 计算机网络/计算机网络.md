# 计算机网络

## TCP/IP五层模型

对于同一台设备上的进程间通信，有很多种方式，比如管道，消息队列，共享内存，信号等，而对于不同设备间的进程间通信，就需要应用网络通信了，由于网络的异构性，协商出了一套通用的网络模型，分为五层，应用层，运输层，网络层，数据链路层，物理层。

> 七层模型：应用层、表现层、会话层、运输层、网络层、数据链路层、物理层

### 应用层

我们能直接接触的就是应用层，电脑或手机上的应用软件都是在应用层实现的。**应用层要做的就是定义好应用进程之间的通信规则**。就是要定义好一个个的应用层协议。比如万维网的HTTP协议，电子邮件的SMTP协议，文件传输协议FTP等，应用层还有一个重要的，就是这些协议都需要用到IP，因此就需要根据域名解析出IP地址的域名系统DNS。

> 应用层交互的数据单元称为报文。

### 运输层

应用层的数据包会传给运输层，运输层是为应用层提供支持的。真正通信的实体是主机中的进程，是一台主机中的一个进程和另一台主机的一个进程交换数据（即通信），**运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务（端到端）**。

> 由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。复用是指发送方不同的应用进程都可以使用同一个运输层传送数据（需要加上适当的首部），而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。

运输层主要使用两个协议

- 传输控制协议TCP：提供面向连接的，可靠的数据传输服务
- 用户数据报协议UDP：无连接的，尽最大努力交付的数据传输服务

### 网络层

网络层的任务就是选择**合适的路由器和交换节点**，确保数据的**及时传输**。

网络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装成 IP 报⽂，如果 IP 报⽂大小超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚（IP头部有片位移字段），得到⼀个即将发送到⽹络的 IP 报⽂。

<img src="https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222204914873.png" alt="image-20220222204914873" style="zoom:80%;" />

> IP协议：实现网络互连，使参与互连的性能各异的网络从用户看起来好像是一个统一的网络。而熟知的互联网就是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。
>
> - 地址解析协议ARP：知道了一个机器（主机或路由器）的IP地址，得到它的硬件地址，由于IP协议使用了ARP，就把ARP划归网络层

### 数据链路层

**数据在⼀个链路中传输，这就是数据链路层（Data LinkLayer），它主要为⽹络层提供链路级别传输的服务**。每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。

![image-20220222210846616](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222210846616.png)

> 在以太网传输数据是以帧为单位传送的，就是上面这个格式
>
> FCS: 4字节的帧检验序列(使用循环冗余检验CRC)

### 物理层

**屏蔽掉传输媒体和通信手段的差异**，当数据准备要从设备发送到⽹络时，需要把数据包转换成比特流，以电信号的形式（1：高电平，0：低电平）让其可以在物理介质中传输，这⼀层就是物理层（Physical Layer），它主要是为数据链路层提供⼆进制传输的服务。

> 传输媒体：双绞线，同轴电缆，光缆，各种波段的无线信道。



## 熟知端口号

| 应用程序   | FTP   | HTTPS | TELNET | SMTP | DNS  | HTTP | SSH  | MYSQL | REDIS |
| ---------- | ----- | ----- | ------ | ---- | ---- | ---- | ---- | ----- | ----- |
| 熟知端口   | 21,20 | 443   | 23     | 25   | 53   | 80   | 22   | 3306  | 6379  |
| 传输层协议 | TCP   | TCP   | TCP    | TCP  | UDP  | TCP  | TCP  | TCP   | TCP   |

> FTP 21是默认端口号，传输控制信息端口，20传输数据端口
>
> 熟知端口号：0~1023
>
> 登记端口号：1024~49151
>
> 客户端使用的端口号：49152~65535



## TCP和UDP的区别

![image-20220222220658934](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222220658934.png)

>TCP：传输控制协议。
>
>UDP：用户数据报协议。

- 1、UDP是无连接的，发送数据之前不需要建立连接，而TCP是面向连接的运输层协议，应用程序在使用TCP协议之前，必须建立TCP连接，传输数据完毕之后，必须释放已经建立的TCP连接。
- 2、UDP不保证可靠交付，只是尽最大努力交付，而TCP提供可靠交付服务，通过TCP连接传送的数据**无差错、不丢失、不重复，并且按序到达**
- 3、**UDP是面向报文**的，对应用层交下来的报文不合并也不分拆，给多大的报文就发送多大，UDP一次交付一个完整的报文，**UDP不会有粘包拆包问题**，而**TCP面向字节流，会有粘包拆包问题。**
- 4、UDP没有拥塞控制，因此网络出现拥塞的时候也不会使源主机发送速率降低（可能引起严重的拥塞问题），而TCP会有拥塞控制（慢开始，拥塞避免，快重传，快恢复）
- 5、UDP主要有一点，就是效率高，比较快，**UDP**对于一些实时应用是很重要的，（微信语音，实时视频会议）等**允许网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延**，UDP正好适合这个场景，TCP一般用于文件传输、发送和接收邮件、远程登录等场景（FTP,SMTP,SSH,MySQL）【要求数据不能有差错，可靠数据为准】。
- 6、UDP支持一对一、一对多、多对一、多对多的交互通信，而TCP提供全双工通信。
- 7、UDP头部八个字节，TCP头部最小长度20字节，最大可以扩展到60字节

![image-20220223000200326](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223000200326.png)

![image-20220223000227062](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223000227062.png)



## TCP的三次握手

三条线就代表了三次握手

可以从`SYN和ACK`以及`seq`这两方面去理解三次握手的含义。

![image-20220222213318229](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222213318229.png)

​	**第一次握手**中，TCP报文段中，若发现 **SYN = 1而 ACK = 0**表明这是一个**连接请求报文**，当B接受到此报文段之后，TCP模块首先会检查包的接收方端口号，确认有没有与之对应的正在等待连接的套接字。

- 如果指定端口号没有正在等待连接的套接字，就会向客户端返回错误通知的包
  - 向客户端返回一个表示接收方端口不存在等待连接的套接字的ICMP消息
- 如果存在等待连接的套接字，就会为这个套接字复制一个新的副本，并把发来的包的TCP头部字段的一些信息（发送方端口号【最重要】，序号初始值、窗口大小）等参数写入新的套接字，然后就会生成代表接受确认的ACK号，生成TCP头部（接收方端口号、序号、窗口等，**这里没有IP地址，IP地址由下层的IP模块负责**），委托IP模块发送给客户端。

​	**第二次握手**，就是接收方发送 **SYN = 1, ACK = 1**，客户端看到TCP头部中这两个字段就知道是**连接接受报文**

​	**第三次握手，**客户端返回表示接受确认的ACK = 1

​	这里说到了套接字，创建套接字的本质就是分配用于套接字的内存空间。`Socket库中的一些API(read,write,close,bind,listen)用来操作套接字`。确定某个套接字的时候，用四个信息来判断，客户端的IP地址和端口号，服务端的IP地址和端口号

​	**套接字**就是一个概念，协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP地址、端口号、通信操作的进行状态，这些就是套接字

### 为什么要三次握手？

1、主要目的是使发送方和接收方都知道对方的存在，确认发送和接受是正常的。`ACK和SYN`

2、交换一些头部信息，能够合理发送数据，相互告诉自己的初始序号，使得通信双方步调一致，完成后续的数据收发操作。`seq`

**主要目的是使发送方和接收方都知道对方的存在，确认发送和接受是正常的。**

- 第一次握手之后（SYN = 1，连接请求报文）
  - 接收方确认：发送方发送正常，自己接受正常，发送方确认：无
- 第二次握手之后（SYN = 1,ACK = 1，连接接受报文）
  - 发送方确认：自己发送和接受正常，接收方发送和接受正常。
  - 接收方确认：发送方发送正常，自己接受正常
  - 这个时候发送方的状态就是可以建立连接了。
- 第三次握手之后（ACK = 1，这次握手可以发送数据）
  - 发送方确认：自己发送和接受正常，接收方发送和接受正常。
  - 接收方确认：自己发送和接受正常，发送方发送和接受正常
  - 这时候接收方的状态就是可以建立连接了。
- 所以三次握手后，双方都知道 双方发送和接受是没问题的，这时候双方就建立了连接。

**能够合理发送数据**

- 实际通讯过程中，序号不可以从1开始，这样很容易猜测通信过程。因此初始值是要随机的，因此，就必须告知对方自己的初始序号！因此需要在开始收发数据之前将初始值告知通信对象。

- 注意看上面的图，发送方进行第一次握手的时候，告诉接收方自己的初始序号
- 接收方进行第二次握手的时候，告诉发送方自己的初始序号
- 这个时候，双方的序号同步完成，明白了当真正的数据过来的时候要从什么序号开始接受，完成了数据收发的准备工作。

### 发送方为什么要发送最后一次确认？

假设A是发送方，B是接收方

​	像前面说的，一来是为了**让双方都知道 发送和接受没有问题并且同步好了双方的序号**，二来主要是**为了防止已经失效了的请求连接报文突然又发送给了接受方，产生错误**。

​	所谓已失效的请求连接报文段是这样的，A第一次发了一个连接请求，但是这个请某个网络结点长时间滞留住了，由于超时重传，因此A又发了一个连接请求，这次正常建立了连接。数据传输完毕之后，释放了连接。

​	假如这个时候，那个长时间滞留的报文段，正常的发给了B会怎样？B接受到之后，会认为A又发出了一次请求连接，于是发出连接接受报文段，同意建立连接。若只采用两次握手的话，那么只要B发出确认，新的连接就建立了。

​	由于现在A并没有发出建立连接的请求，因此A不会理会B的确认，也不会向B发送数据，但是B却以为新的连接建立了，并一直等待A的数据，B的许多资源就这样浪费了。

**因此，采用三报文握手的方法可以阻止上述现象的发生，例如在上面的异常情况发生的时候，只要A没有向B发出确认（即第三次握手），那么B由于收不到确认，就不会建立连接**

### 第三次握手的特殊性

第三次握手从结果上看，是为了让B建立起连接。

第一次握手和第二次握手都会消耗掉一个序号，而且不能携带数据

但是第三次握手是可以携带数据的，如果携带了数据，就要消耗掉一个序号，如果没有携带数据的话就不会消耗序号

注意看上面那幅图，发送方发送完确认后，就建立了连接，这个时候双方的序号是已经同步了的，这个时候发数据是没有任何问题的。意味着，如果第三次握手的ACK报文段丢失了也没有关系，只要紧接着发送带有数据的报文段且被B收到，由于序号和确认号与第三次握手一样，那么发送的数据报也充当了第三次握手的ACK报文，B仍然可以建立连接。

> HTTP协议过程中，就是在第三次握手的时候，携带上了HTTP报文。



## TCP的四次挥手

![image-20220222213348603](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222213348603.png)

1、客户端进程发出**连接释放报文**，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 **TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。**

2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是**服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。**

3、客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（**在这之前还需要接受服务器发送的最后的数据**）。

4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。**注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。**

6、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。**可以看到，服务器结束TCP连接的时间要比客户端早一些。**



### 为什么客户端最后还要等待2MSL？

默认2MSL=4分钟

第一，保证客户端发送的最后一个ACK报文能够到达服务器（**服务器收到ACK后才关闭TCP连接**），因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的**请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。**

第二，经过2MSL，就可以使本次TCP连接时间内产生的所有报文段从网络中消失。这样新的连接中不会出现旧连接的请求报文。防止类似于“三次握手”中的“已经失效的连接请求报文段”出现在本连接中。



### 为什么建立连接是三次握手，关闭连接却是四次挥手呢？

​	建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

> 其实ACK和SYN也可以分开发送，先发送一个确认报文段（ACK=1，ack=x+1），再发送一个同步报文段（SYN=1,seq=y），这样就变成了四报文握手，不过实际上没有这样做，（ACK=1，SYN=1是一块发送的，表示这是一个连接接受报文段）



### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。




## TCP协议如何保证可靠传输？

TCP发送的报文段是交给IP层的，而IP层只是尽最大努力的交付，也就是说，TCP下面的网络提供的是不可靠传输。**使用可靠的传输协议**，当出现差错时让发送方**重传差错的数据**，同时在接收方来不及处理收到的数据时，**及时告诉发送方适当降低发送数据的速度**，这样一来，本来不可靠的传输信道就能够实现可靠传输。

- 可靠的传输协议：停止等待协议->连续ARQ协议->滑动窗口协议
- 降低发送速度
  - 流量控制，TCP利用滑动窗口实现流量控制。
  - 拥塞控制，慢开始，拥塞避免，快重传，快恢复。

- **检测错误可以依靠TCP头部的校验和**，TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

### 停止等待协议：ARQ

停止等待就是每发送完一个分组（报文段）就停止发送，等待对方的确认。收到确认后再发送下一个分组。

![image-20220222233042802](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222233042802.png)

![image-20220222233137579](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222233137579.png)

**确认丢失和确认迟到时候的策略**

![image-20220222233302487](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222233302487.png)

使用上述的**确认和重传机制**，就可以在不可靠的传输网络上实现可靠的通信，**上述这种可靠传输协议称为自动重传请求ARQ**

- 优点：简单
- 缺点：信道利用率太差

可使用流水线传输，就是发送方可以连续发送多个分组，即**连续ARQ协议和滑动窗口协议**

### 连续ARQ协议

![image-20220222233733522](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220222233733522.png)

上图是发送方维持的发送窗口，位于发送窗口内的5个分组都可以连续发送出去，不需要等待对方的确认。

连续ARQ协议规定，发送方每收到一个确认就把发送窗口向前滑动一个分组。而**接收方采取累计确认**，对**按序到达的最后一个分组发送确认**，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

**缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 **Go-Back-N（回退 N）**，表示需要退回来重传已经发送过的 N 个消息。

### 滑动窗口协议

TCP的滑动窗口是以字节为单位的，如下图，是一个发送窗口的示例。核心就是三个指针维护着发送窗口的状态。

![image-20220223000342781](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223000342781.png)

![image-20220223000511985](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223000511985.png)

![image-20220223000652659](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223000652659.png)

![image-20220223000739638](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223000739638.png)

![image-20220223000858725](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223000858725.png)

![image-20220223001035489](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223001035489.png)

三个指针，P1、P2、P3

- P1之前的就是已经发送完成并且确认了的数据
- P1-P2之间的就是已经发送还未确认数据
- P2-P3就是还没有发送的数据
- P3之后就是不允许发送的数据

一、TCP通常对**不按序到达的数据临时存放在接受窗口**中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。

二、TCP要求**接收方有累计确认的功能**，这样可以减少传输开销。

三、发送窗口的大小swnd=min（rwnd，cwnd）。rwnd是接收窗口，cwnd用于拥塞控制

四、什么时候重传：因为每个报文都有超时计数器，超时才重传。

五、tcp缓存和窗口的关系：窗口是缓存的一部分。

六、发送缓存=发送窗口+ P3右边的一部分

七、接收缓存=接收窗口+部分已确认但主机还没处理完的数据。

#### 超时重传时间的选择

TCP的发送方在规定时间内没有收到确认就要重传已发送的报文段。

TCP采用了一种自适应的算法，超时计时器设置的**超时重传时间 RTO  = RTTs + 4RTTd**

> RTT：报文段的往返时间
>
> RTTd： RTT 的偏差的加权平均值
>
> RTTs:加权平均的RTT
>
> Karn算法:报文段每重传一次，就把超时重传时间RTO增大一倍，当不发生报文段重传时，RTO  = RTTs + 4RTTd



### 流量控制

流量控制就是让发送方发送速度不要太快，要让接收方来得及接收。

![image-20220223122944723](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223122944723.png)

看最后一个确认时，rwnd=0，即不允许发送方再发送数据了，假如这时候接收方又发了一个rwnd=400的报文段，但是这个报文段丢失了怎么办？为了解决这个问题，TCP为每个连接设有一个**持续计时器**，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，时间一到，就会发送一个零窗口探测报文段，而对方就会给出现在的窗口值，如果窗口仍然是0，那么重设计时器，否则死锁的情况就打破了。

#### Nagle算法

TCP实现中广泛使用了Nagle算法。算法如下：若发送应用进程把要发送的数据逐个字节地发送到TCP的发送缓存，则**发送方就把第一个数据字节先发送出去**，把**后面到达的数据字节都缓存起来**。当发送方收到对第一个数据字符的确认后，再把发送缓存中的**所有数据组装成一个报文段**发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后，才继续发送下一个报文段。

> 当数据到达较快而网络速率较慢时，这样做可以明显减少所有的网络带宽。
>
> Nale算法还规定：当**到达的数据已到达发送窗口大小的一半或者已达到报文段的最大长度**时，就立即发送一个报文段。

### 拥塞控制

在某段时间，若对网络中某一资源（路由器，交换机等）的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

解决拥塞的两条思路

- 增加网络可用资源
- 减少用户对资源的需求

**拥塞控制就是防止过多的数据注入到网络中**，这样可以使网络中的路由器或链路不致于过载。

TCP进行拥塞控制的算法有四种：慢开始、拥塞避免、快重传、快恢复。

![image-20220223125022825](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223125022825.png)

**慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次（往返时间RTT），cwnd 加倍。

**拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.

**慢开始门限ssthresh**：处理拥塞时参照的一个参数。例子中初始值为16，后来变为12（超时），再变为8（3-ACK）。

当cwnd< ssthresh，cwnd以慢开始的方法指数增长；

当cwnd> ssthresh，cwnd以拥塞避免的方法线性增长。

**快重传：**一连收到3个重复的确认（3-ACK），就立即重传

**快恢复：**快重传与快恢复搭配，`ssthresh = rwnd / 2,rwnd = ssthresh`，然后执行拥塞避免算法

> 为什么是快恢复呢？主要就是拥塞窗口减少为目前的一半，而超时（拥塞）情况下，`ssthresh = rwnd / 2,rwnd = 1`，因此叫做快恢复

> AIMD算法：拥塞避免是线性增长，称为加法增大AI（Additive Increase），一旦出现超时或者3个重复确认，把门限值sshresh设置为当前拥塞窗口的一半，称为乘法减小MD（Multiplicative Decrease）。



**通过以上的方式，使用了可靠的传输协议，遇到差错后及时重传，在接收方接受速率没那么快的情况下及时减少发送方的发送速率，就可以实现TCP的可靠传输了。因此，可靠传输由运输层的TCP实现，下层不用保证可靠传输，只需要尽最大努力交付即可。**



##  在浏览器中输入 url 地址 ->> 显示主页的过程

### 1、解析URL--生成HTTP请求报文

输入URL后，浏览器第一步就是要解析这个URL，并生成HTTP请求报文。

<img src="https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223132340702.png" alt="image-20220223132340702" style="zoom:80%;" />

对URL解析后，浏览器确定了Web服务器和文件资源，接下来就是根据这些信息来生成HTTP请求报文。

![image-20220223132956981](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223132956981.png)

请求报文的例子

![image-20220223133034492](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223133034492.png)

响应报文的例子

![image-20220223133119672](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223133119672.png)

![image-20220223133322208](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223133322208.png)

![image-20220223133339526](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223133339526.png)

解析完URL后，就知道了域名，我们需要根据这个域名查到IP地址

### 2、真实地址查询，DNS

通过浏览器解析 URL 并⽣成 HTTP 消息后，需要**委托操作系统将消息发送给 Web 服务器**。
但在发送之前，还有⼀项⼯作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

> DNS 中的域名都是⽤句点来分隔的，⽐如 www.server.com ，这⾥的句点代表了不同层次之间的界限。
>
> 在域名中，越靠右的位置表示其层级越⾼。
>
> 根域是在最顶层，它的下⼀层就是 com 顶级域，再下⾯是 server.com。
>
> 所以域名的层级关系类似⼀个树状结构：
>
> - 根 DNS 服务器
> - 顶级域名 DNS 服务器
> - 权限域名 DNS 服务器
> - 本地域名服务器（当一台主机发出DNS查询请求时，就是发给本地域名服务器）
>
> ![image-20220223134351914](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223134351914.png)

一、主机向本地域名服务器的查询一般是**递归查询**，即，让本地域名服务器以DNS客户的身份，向其他根域名服务器发出查询请求

二、本地域名服务器向根域名服务器的查询是**迭代查询**，即，当根域名服务器收到迭代查询的请求报文时，要么回复一个IP，要么让本地域名服务器再向顶级域名服务器查询。

![image-20220223134443975](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223134443975.png)

![image-20220223134516294](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223134516294.png)

为了提高查询效率，在域名服务器中广泛使用了高速缓存，高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录

> windows下 ipconfig /displaydns 来进行查看系统内的dns缓存。ipconfig /flushdns来清除
>
> **要进行域名解析，首先，查看dns缓存中有没有对应ip，再看hosts文件有没有对应ip，没有的话再进行DNS查询。**



#### 本地域名服务器在哪？

在通过浏览器缓存及host文件都无法解析域名的情况下，OS会将这个域名发送给计算机网络配置中DNS对应的地址（LDNS），即本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务，假如是在学校接入的互联网，那么这个本地区的域名服务器基本上是在学校中（网络中心）；如果是在小区接入的互联网，那么这个本地区的域名服务器就是提供给你接入互联网的应用服务上，也就是电信或联通。



### 3、浏览器委托操作系统中的协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的协议栈。

上⾯的部分会向下⾯的部分委托⼯作，下⾯的部分收到委托的⼯作并执⾏。

![image-20220223140029967](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223140029967.png)

应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发数据的TCP 和 UDP 协议，它们会接受应⽤层的委托执⾏收发数据的操作。
协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。

> IP中包含ICMP协议和ARP协议：
>
> - ICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息。
> - ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址。

IP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线中的信号执⾏发送和接收操作。

### 4、可靠传输的TCP

HTTP是基于TCP协议传输的。此时开始生成TCP头部和数据报

> TCP 传输数据之前，要先三次握⼿建⽴连接
>
> 在第三次握手的时候，就可以把HTTP报文顺带发出去了。
>
> 如何查看 TCP 的连接状态？
>
> TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。
>
> ![image-20220223141509458](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223141509458.png)

如果 HTTP 请求消息⽐较⻓，超过了 MSS 的⻓度，这时 TCP 就需要把 HTTP 的数据拆解成⼀块块的数据发送，⽽不是⼀次性发送所有数据。

![image-20220223141623926](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223141623926.png)

- MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节。
- MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度。

数据会被以 MSS 的⻓度为单位进⾏拆分，拆分出来的每⼀块数据都会被放进单独的⽹络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![image-20220223141718815](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223141718815.png)

### 5、远程定位的IP

TCP数据报加上IP头部。

在 IP 协议⾥⾯需要有**源地址 IP 和 ⽬标地址 IP**：

- 源地址IP，即是客户端输出的 IP 地址；
- ⽬标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06 （⼗六进制），表示协议为 TCP。

> 假设客户端有多个⽹卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？
>
> 这个时候就需要根据路由表规则，来判断哪⼀个⽹卡作为源地址 IP。
>
> 在 Linux 操作系统，我们可以使⽤ route -n 命令查看当前系统的路由表。

![image-20220223141217400](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223141217400.png)

> 第三条⽬⽐较特殊，它⽬标地址和⼦⽹掩码都是 0.0.0.0 ，这表示**默认⽹关**，**如果其他所有条⽬都⽆法匹配，就会**
> **⾃动匹配这⼀⾏**。并且后续就把包发给路由器， Gateway 即是路由器的 IP 地址。

举个例⼦，根据上⾯的路由表，我们假设 Web 服务器的⽬标地址是 192.168.10.200 。

![image-20220223141226826](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223141226826.png)

### 6、两点传输 MAC---ARP协议工作过程

⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部。

在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输。

**发送⽅**的 MAC 地址获取就⽐较简单了，MAC 地址是在⽹卡⽣产时写⼊到 ROM ⾥的，只要将这个值读取出来写⼊到 MAC 头部就可以了。

**接收⽅**的 MAC 地址就有点复杂了，只要告诉以太⽹对⽅的 MAC 的地址，以太⽹就会帮我们把包发送过去，那么很显然这⾥应该填写对⽅的 MAC 地址。

ARP协议，根据IP地址查MAC地址。

- 主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。
- 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给主机。
- 操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC地址。不过，MAC 地址的缓存是有⼀定期限的，超过这个期限，缓存的内容将被清除。

![image-20220223142120410](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223142120410.png)

> 在 Linux 系统中，我们可以使⽤ arp -a 命令来查看 ARP 缓存的内容。
>
> ```bash
> [root@VarerLeet2 ~]# arp -a
> ? (192.168.200.1) at 00:50:56:c0:00:08 [ether] on ens33
> gateway (192.168.200.2) at 00:50:56:fa:4f:2b [ether] on ens33
> ```

### 7、出口：网卡

⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此，我们需要将数字信息转换为电信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程。

负责执⾏这⼀操作的是**⽹卡**，要**控制⽹卡还需要靠⽹卡驱动程序**。

⽹卡驱动从 IP 模块获取到包之后，会将其复制到⽹卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符**，在**末尾加上⽤于检测错误的帧校验序列**。

![image-20220223142356452](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223142356452.png)

- 起始帧分界符是⼀个⽤来表示包起始位置的标记
- 末尾的 FCS （帧校验序列）⽤来检查包传输过程是否有损坏

最后⽹卡会将包转为电信号，通过⽹线发送出去。

### 8、来到交换机

电信号到达⽹线接⼝，交换机⾥的模块进⾏接收，接下来交换机⾥的模块将电信号转换为数字信号。

利用包末尾的FCS检验错误，如果没问题就放到缓冲区。

以太网交换机的自学习功能。

- 交换机会把每个帧的源地址和来自哪个端口，写入自己的交换表中
- 并根据这个交换表，决定将包发往哪个端口

![image-20220223142908736](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223142908736.png)

举个例⼦，如果收到的包的接收⽅ MAC 地址为 00-02-B3-1C-9C-F9 ，则与图中表中的第 3 ⾏匹配，根据端⼝列
的信息，可知这个地址位于 3 号端⼝上，然后就可以通过交换电路将包发送到相应的端⼝了。

**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端⼝。**

> 当 MAC 地址表找不到指定的 MAC 地址会怎么样？
>
> 地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备⼀段
> 时间没有⼯作导致地址被从地址表中删除了。
>
> 这种情况下，**交换机⽆法判断应该把包转发到哪个端⼝，只能将包转发到除了源端⼝之外的所有端⼝上，⽆论该设**
> **备连接在哪个端⼝上都能收到这个包。**
>
> 此外，如果接收⽅ MAC 地址是⼀个⼴播地址，那么交换机会将包发送到除源端⼝之外的所有端⼝。
>
> 以下两个属于⼴播地址：
>
> - MAC 地址中的 FF:FF:FF:FF:FF:FF
> - IP 地址中的 255.255.255.255

### 9、来到路由器

> **路由器的包接收操作**

⾸先，电信号到达⽹线接⼝部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进⾏错误
校验。

如果没问题则检查 MAC 头部中的接收⽅ MAC 地址，看看是不是发给⾃⼰的包，如果是就放到接收缓冲区中，否
则就丢弃这个包。
总的来说，路由器的端⼝都具有 MAC 地址，只接收与⾃身地址匹配的包，遇到不匹配的包则直接丢弃。

> **查询路由表确定输出端⼝**

完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。
MAC 头部的作⽤就是将包送达路由器，其中的接收⽅ MAC 地址就是路由器端⼝的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。
接下来，路由器会根据 MAC 头部后⽅的 IP 头部中的内容进⾏包的转发操作。
转发操作分为⼏个阶段，⾸先是查询路由表判断转发⽬标。

![image-20220223144127300](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223144127300.png)

1、假设地址为 10.10.1.101 的计算机要向地址为 192.168.1.100 的服务器发送⼀个包，这个包先到达图中的路由器。
2、判断转发⽬标的第⼀步，就是根据包的接收⽅ IP 地址查询路由表中的⽬标地址栏，以找到相匹配的记录。
3、路由匹配和前⾯讲的⼀样，每个条⽬的**⼦⽹掩码**和 192.168.1.100 IP 做 & **与运算**后，得到的结果与对应条⽬的⽬标地址进⾏匹配，如果匹配就会作为候选转发⽬标，如果不匹配就继续与下个条⽬进⾏路由匹配。
4、如第⼆条⽬的⼦⽹掩码 255.255.255.0 与 192.168.1.100 IP 做 & 与运算后，得到结果是 192.168.1.0 ，这与第⼆条⽬的⽬标地址 192.168.1.0 匹配，该第⼆条⽬记录就会被作为转发⽬标。
5、**实在找不到匹配路由时，就会选择默认路由，路由表中⼦⽹掩码为 0.0.0.0 的记录表示「默认路由」。**

> **路由器的发送操作**

1、⾸先，我们需要根据路由表的⽹关列判断对⽅的地址。（看看是要直接交付还是间接交付）

- 如果⽹关是⼀个 IP 地址，则这个IP 地址就是我们要转发到的⽬标地址，还未抵达终点，还需继续需要路由器转发。（间接交付）
- 如果⽹关为空，则 IP 头部中的接收⽅ IP 地址就是要转发到的⽬标地址，也是就终于找到 IP 包头⾥的⽬标地址了，说明已抵达终点。（直接交付）

2、知道对⽅的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收⽅MAC 地址。
3、路由器也有 ARP 缓存，因此⾸先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

4、接下来是发送⽅ MAC 地址字段，这⾥填写输出端⼝的 MAC 地址。还有⼀个以太类型字段，填写 **0800 （⼗六进制）表示 IP 协议**。

5、发送出去的⽹络包会通过交换机到达下⼀个路由器。由于接收⽅ MAC 地址就是下⼀个路由器的地址，所以交换机会根据这⼀地址将包传输到下⼀个路由器。
6、接下来，下⼀个路由器会将包转发给再下⼀个路由器，经过层层转发之后，⽹络包就到达了最终的⽬的地。

**网络包传输过程中，源IP和目标IP不变，一直变化的是MAC地址，因为需要MAC地址在两个目标之间传输。**

### 10、到达服务器

1、数据包到达服务器后，看MAC地址是否合适，再看看FCS有没有出错

2、再看IP地址是否符合，根据IP头中的协议项06 （⼗六进制），知道自己的上层是TCP

3、然后看TCP头部，80端口，HTTP有Socket正在监听这个端口号，服务器就会将包发给HTTP进程

4、HTTP进程根据请求报文，知道这个请求要访问一个页面，就把网页html封装在响应报文里。

### 11、响应给客户端

响应报文也要装上TCP头部，IP头部，MAC头部，从网卡发出去，到达交换机，由路由器转发，回到客户端，然后根据HTTP响应报文渲染页面。

最后客户端发现此次请求结束了，于是就有了**四次挥手**，双方的连接就断开了【2MSL后】。



## 状态码

![image-20220223151206962](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220223151206962.png)

- 200：请求已正常处理
- 300  （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
- 301：永久性转移，请求的网页从a转移到了b
- ![image-20220223151340331](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220223151340331.png)
- 302  （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- **307 Temporary Redirect**
  - 临时重定向。该状态码与302有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。 **307会遵照浏览器标准，不会从POST变成GET**。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

- 400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。
- 401 Unauthorized：该状态码表示发送请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。
  - <img src="https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220323165215064.png" alt="image-20220323165215064" style="zoom:67%;" />

- 403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）
- 404 Not Found：服务器上没有请求的资源。路径错误等。
- 500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。
- 502  （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
- 503 Service Unavailable：由于临时的服务器维护或者过载，服务器当前无法处理请求。



## HTTP协议

HTTP协议**定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档**，以及服务器怎样把文档传给客户端。它是万维网上能够**可靠**交换文件（文本、声音、图像等）的基础。

**HTTP使用面向连接的TCP作为运输层协议**，保证了数据的可靠传输。但是HTTP协议本身是无连接的，通信双方交换HTTP报文之前不需要建立HTTP连接。

HTTP协议是无状态的，同一个客户第二次访问同一个服务器的页面时，服务器的响应与第一次被访问时相同，因为服务器并不记得增进访问过这个客户，也不记得为该客户曾经服务过多少次。

从浏览器请求一个万维网文档到收到整个文档所需的时间大约是2RTT。（一个RTT用于TCP连接，三报文握手的前两部分，另一个RTT用于请求和接收万维网文档），TCP建立连接的三报文握手的第三个报文段中的数据，就是请求报文



### HTTP 1.0 和 HTTP 1.1 的主要区别是什么?

HTTP/1.0默认使用的是短连接，每请求一个文档就需要2RTT的开销，每次请求都需要三次握手四次挥手的开销。

> Connection： close

HTTP/1.1默认使用的是长连接，服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。

> Connection: keep-alive

**HTTP/1.1 的持续连接有非流水线方式和流水线方式** 。

非流水线方式的特点，客户在收到前一个响应后才能发出下一个请求。因此在TCP连接已建立后，每访问一个服务器都需要用去一个往返时间RTT。

流水线方式的特点，客户在收到HTTP的响应报文之前就能够接着发送新的报文请求，于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文，因此使用流水线，客户访问所有对象只需要一个RTT时间。



### HTTP 是不保存状态的协议, 如何保存用户状态?

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们如何保存用户状态呢？

**Session 机制**的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

> **Cookie 被禁用怎么办?**
>
> 最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。



### HTTP和HTTPS的区别？

**端口** ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

**安全性和资源消耗：** HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；
- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。

![image-20220228115332083](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220228115332083.png)

> SSL(Secure Socket Layer): 安全套接字层协议
>
> TLS(Transport Layer Security):传输层安全协议



#### 对称加密和非对称加密

SSL/TLS 的核心要素是**非对称加密**。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。（公钥加密需要私钥解密，私钥加密需要公钥解密）。

使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，**SSL/TLS 实际对消息的加密使用的是对称加密**。

在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，**通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。**



#### 公钥传输的信赖性

设想一个下面的场景：

客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：

1. 任何人都可以捕获通信包
2. 通信包的保密性由发送者设计
3. 保密算法设计方案默认为公开，而（解密）密钥默认是安全的

因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个**攻击者 A，发送给 C 一个诈包**，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。

同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！

**为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的电子签名 。**

当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。



#### 数字签名

数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是靠数字签名技术。

数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：

**数据传输前，需要交换双方用于对称加密的密钥**

- 1、浏览器A向服务器B发送浏览器的SSL版本号和一些可选的非对称加密算法,以及**生成客户端随机数（会被服务器端保留）**
- 2、服务器B从中选定自己支持的非对称加密算法（如RSA），**生成服务器端的随机数**，然后告诉浏览器A
- 3、服务器B还会向浏览器A发送包含其RSA公钥的数字证书。
  - 对于这个数字证书，服务器B会去找CA，CA对证书做签名后返回给服务器B。

- 4、浏览器A使用该证书的认证机构CA公开发布的公钥对该证书进行验证。
- 5、若证书验证成功，由浏览器A再随机生成一个随机数，刚才所说的三次随机数就是用来生成密钥的。用服务器B的RSA公钥对最后这个随机数进行加密后发给B，B用私钥解密后，也就知道了密钥。
- 6、现在双方根据协商的算法产生共享的对称会话密钥
- 7、安全数据传输。双方用会话密钥加密和解密它们之间传送的数据并验证其完整性。

<img src="https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220312002537940.png" alt="image-20220312002537940" style="zoom:67%;" />

服务器端的证书，都需要经过CA签名，这个证书才能被信任。

![image-20220312002414409](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220312002414409.png)

**证书链确保这个证书可信（防止CA是伪造的情况），操作系统一般都会内置一些根证书**

- 就是如果我不信任你这个CA机构的话，就是这个证书的签发者不是根证书，无法通过本地已有的根证书的公钥去验证这个证书是否可信，那么我会去询问我的根证书，让它来担保目前这个证书是否可信。

![image-20220329125750847](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220329125750847.png)





## Cookie 和 Session

### Cookie的工作原理

（1）浏览器端第一次发送请求到服务器端
（2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端（包含在响应头中）
（3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie(包含在请求头中)
（4）服务器端通过Cookie中携带的数据区分不同的用户

![image-20220224211027178](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220224211027178.png)

### Session的工作原理

（1）浏览器端第一次发送请求到服务器端，服务器端创建一个Session（需要显示的getSession才会创建），同时会创建一个特殊的Cookie（**name为JSESSIONID的固定值，value为session对象的ID**），然后将该Cookie发送至浏览器端
（2）浏览器端发送第N（N>1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象
（3）服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。

> session的默认存活期是30分钟

![image-20220224211359410](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220224211359410.png)

### Cookie的作用

1、Http是无状态的，第一次登录时，通过在响应报文中写入Cookie（响应头有一个Set-Cookie的字段），来保存一些用户的信息（主要用来唯一标识一个用户，如放一个JESSIONID），下一次请求的时候请求头中有Cookie，服务器就知道是哪一个用户了。

2、登录一次网站后访问网站其他页面不需要重新登录。（设置cookie的domain为父域名，就可以实现一处登录，处处登录）



### Session的作用

**Session 的主要作用就是通过服务端记录用户的状态。**服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。  

- 用户登录后，将用户数据存入Session中备用
  - 每次需要检验登录时，就可以写一个拦截器，根据JSESSION查，查到了就算登录，可以看到这个用户相关信息，放行，查不到，重定向到登录页
- 存每一个用户的购物车，考虑到购物车数据比较大，这里就可以将数据放到内存数据库中，如Redis。
  - 每次根据JSESSIONID拿到用户的唯一标识，去Redis找这个用户的购物车操作即可
  - 购物车如何设计？
    - key : 用户唯一标识,如 cart:100
    - value: hash数据结构（key：商品id,value: 购物项详情）
    - 为什么value用hash？考虑到购物车经常会改动，如+数量，-数量，删除一个购物项，这些操作，对于每一个购物项都有一个唯一的编号，只要根据这个编号，用hash很容易就操作了
      - 如果用list的话，每次根据key取出整个list，只是为了找到一个购物项，效率太低



### Cookie与Session的区别

Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式

1、cookie存放在浏览器，session数据放在服务器上，但是服务端的session的实现对客户端的cookie是有依赖关系的；

- 服务器每次生成Session的时候，都会顺便生成一个Cookie，key为JESSIONID,value为Session对象的id

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，所以cookie是可以伪造的，而session无法伪造

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE

4、**单个cookie在客户端的限制是4K**，就是说一个站点在客户端存放的COOKIE不能4K。而SESSION没有限制，太大的话可以考虑放到数据库中

5、session过期与否，取决于服务器的设定。cookie过期与否，可以在cookie生成的时候设置进去。

- 默认情况下，cookie数据保存到内存里，当浏览器关闭后，Cookie数据被销毁，若设置了Cookie的生存时间，会将Cookie数据写到硬盘的文件中持久化存储，时间到期后，cookie文件自动失效
- session的默认时间是30分钟

所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中

> 项目中用到的，cookie放 JSESSIONID ，服务器从Redis查JSESSIONID拿到用户对应的Session



## sessionid的安全性问题

一般用session管理用户登录信息，会将sessionid放到cookie中，下次用户请求时，根据cookie中的sessionid识别用户身份

1、部署HTTPS防止SessionID被窃取。

2、设置Cookie的HttpOnly属性防止XSS（跨站脚本攻击）攻击

3、更改SESSIONID的名称，让攻击者不分析站点的话，就不能猜到SESSIONID的名称，阻挡部分攻击

4、当登录地点发生变动时，要求用户重新登陆，例如使用User-Agent、IP地址等检测请求的一致性

5、偷偷在前端放一个token，请求时校验token

> **Http Header之User-Agent**
>  User Agent中文名为用户代理，是Http协议中的一部分，属于头域的组成部分，User Agent也简称UA。它是一个特殊字符串头，是一种向访问网站提供你所使用的浏览器类型及版本、[操作系统](https://link.jianshu.com?t=http://lib.csdn.net/base/operatingsystem)及版本、浏览器内核、等信息的标识。通过这个标 识，用户所访问的网站可以显示不同的排版从而为用户提供更好的体验或者进行信息统计；例如用手机访问谷歌和电脑访问是不一样的，这些是谷歌根据访问者的 UA来判断的。
>
> **如何拿到用户IP地址？**
>
> ```java
> public String getRemortIP(HttpServletRequest request) {  
>     if (request.getHeader("x-forwarded-for") == null) {  
>         return request.getRemoteAddr();  
>     }  
>     return request.getHeader("x-forwarded-for");  
> }  
> ```



## URI 和 URL 的区别是什么?

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。

- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 定位这个资源
- URI是对于某一个网站的唯一标识
  - 如下图，http://foo.bar/a.html 就是一个URL，而a.html是相对于www.foo.bar这个网站的URI，用a.html可以在www.foo.bar唯一找到一个名为a.html的资源。

![image-20220224215726024](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220224215726024.png)



## ICMP协议

ICMP(Internet Control Message Protocol)：网际控制报文协议,提供ICMP差错报告报文和询问报文，以提高IP数据报交付成功的机会

![image-20220224230831735](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220224230831735.png)

### ping工作原理：两台主机是否连通

ping: 分组网间探测，用来测试两台主机之间的连通性。

**ping使用了ICMP回送请求与回送回答报文**，ping是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP和UDP。

- 源主机发一个ICMP回送请求消息数据包，ICMP报文类型为8（ECHO REQUEST）
- 目标主机发一个ICMP回送响应消息数据包，ICMP报文类型为0（ECHO REPLY）
- 在规定的时间内，源主机如果**没有接到 ICMP 的应答包，则说明⽬标主机不可达**；如果接收到了 ICMP 回送响应消息，则说明⽬标主机可达。此时，源主机会检查，⽤当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。

![image-20220224225341326](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220224225341326.png)

### traceroute工作原理：跟踪一个分组从源点到终点的路径

traceroute是UNIX或Linux的命令，tracert是Windows下的

![image-20220224231052782](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220224231052782.png)



## 正向代理和反向代理

**正向代理：**一个位于客户端和目标服务器之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并告诉请求目标（目标服务器），然后代理服务器向目标服务器转发这个请求并将得到的内容返回给客户端。

- A向C借钱，由于一些原因无法借到，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。
- ![image-20220321222057525](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220321222057525.png)

**方向代理：**以代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个方向代理服务器。

- A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A，A以为是B的钱，他并不知道C的存在。

- ![image-20220321222336860](https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220321222336860.png)

**两者区别：**

- 位置不同
  - 正向代理架设在客户端与服务器之间
  - 反向代理架设在服务器端。

- 代理对象不同
  - 正向代理代理客户端，服务器端不知道客户端的存在
  - 反向代理代理服务器，客户端不知道实际提供服务的服务器
- 用途不同
  - 正向代理为在防火墙内的局域网客户端提供访问internet的途径
  - 反向代理将防火墙后面的服务器提供给internet访问
- 应用领域不同
  - 正向代理一般拿来翻墙，可以让我们访问国外资源，还可以记录用户访问记录（上网行为管理），对外隐藏用户信息。
  - 反向代理一般用来保护内网安全，做负载均衡（nginx）

> Nginx作为反向代理服务器，安装在目的主机端，主要用于转发客户机请求，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后台的服务器，决定哪台目标主机来处理当前请求。



### 网络包如何发给境外？

VPN隧道，将网络包发给正向代理服务器，由代理服务器负责转发



## VPN

VPN（Virtual Private NetWork）：虚拟专用网

VPN和代理服务器是很接近的。VPN服务下，传输的信息都先经过VPN服务器，然后再抵达目的地，反过来接收过程也一样。**VPN和代理的主要区别就是在于向服务器发送数据的这个环节。使用VPN，VPN软件将加密的数据传递给VPN服务器，这样传输的数据对截获者来说就是不可读的**。这个技术叫做“隧道”。

<img src="https://raw.githubusercontent.com/xuhaoyao/images/master/img/image-20220321233744213.png" alt="image-20220321233744213" style="zoom:67%;" />



## 路由聚合计算

192.168.0.0

192.168.1.0

192.168.2.0

192.168.3.0

将这四条路由进行路由聚合，首先将所要聚合的部分变成比特位

192.168.00000000.0

192.168.00000001.0

192.168.00000010.0

192.168.00000011.0

由此查看，第三部分的前六位是相同的，所以网络号为8+8+6=22，而00000000的十进制位是0，所以聚合后的IP地址为192.168.0.0/22.